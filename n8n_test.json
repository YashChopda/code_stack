{
  "nodes": [
    {
      "parameters": {
        "formTitle": "Doc Diff Generator",
        "formDescription": "Upload two docx files to compare",
        "formFields": {
          "values": [
            {
              "fieldName": "Old doc",
              "fieldLabel": "Older version",
              "fieldType": "file",
              "multipleFiles": false,
              "acceptFileTypes": ".docx",
              "requiredField": true
            },
            {
              "fieldName": "New doc",
              "fieldLabel": "New version",
              "fieldType": "file",
              "multipleFiles": false,
              "acceptFileTypes": ".docx",
              "requiredField": true
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.4,
      "position": [
        0,
        0
      ],
      "id": "88560f86-c41a-43b5-93c5-4970a86a796b",
      "name": "On form submission",
      "webhookId": "f9b7b17e-6f88-4721-a040-27f96bdaecf3"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first();\nconst bin = item.binary || {};\n\nconst OLD_KEY = 'Old_doc';\nconst NEW_KEY = 'New_doc';\n\nif (!bin[OLD_KEY] || !bin[NEW_KEY]) {\n  throw new Error(\n    `Expected binaries \"${OLD_KEY}\" and \"${NEW_KEY}\". Found: ${Object.keys(bin).join(', ')}`\n  );\n}\n\nfunction normalizeToZip(binary, zipName) {\n  // IMPORTANT: do NOT drop or replace binary.data\n  // Just adjust metadata so Compression treats it as a zip container\n  return {\n    ...binary,\n    fileName: zipName,\n    fileExtension: 'zip',\n    mimeType: 'application/zip',\n  };\n}\n\nreturn [\n  {\n    json: { sourceFile: 'old' }, // like the sample solution\n    binary: { data: normalizeToZip(bin[OLD_KEY], 'old.zip') },\n  },\n  {\n    json: { sourceFile: 'new' },\n    binary: { data: normalizeToZip(bin[NEW_KEY], 'new.zip') },\n  },\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        0
      ],
      "id": "0646f378-d2a0-4ee6-bd4f-6295aa4ad912",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.compression",
      "typeVersion": 1.1,
      "position": [
        448,
        0
      ],
      "id": "70a166d9-d84d-4bad-82ea-c30622ef64d3",
      "name": "Compression1"
    },
    {
      "parameters": {
        "operation": "xml",
        "binaryPropertyName": "file_4",
        "options": {
          "encoding": "utf8"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        656,
        0
      ],
      "id": "e8d8ecce-26eb-4086-99f3-3479010e9f09",
      "name": "Extract from File",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// 1. Get all items entering the node\nconst items = $input.all();\n\n// 2. Clean the XML for every item\nconst processed = items.map(item => {\n  const rawXml = item.json.data || \"\";\n  \n  // Strip XML tags and clean whitespace\n  const cleanText = rawXml\n    .replace(/<[^>]+>/g, ' ') \n    .replace(/\\s+/g, ' ')    \n    .trim();\n\n  return {\n    json: {\n      // sourceFile comes from your very first JS node\n      source: item.json.sourceFile || \"unknown\", \n      textBody: cleanText\n    }\n  };\n});\n\n// 3. Perform comparison only if we have exactly two documents\nif (processed.length === 2) {\n  const oldDoc = processed.find(i => i.json.source === 'old');\n  const newDoc = processed.find(i => i.json.source === 'new');\n\n  // Check if both were found before comparing\n  if (oldDoc && newDoc) {\n    processed.push({\n      json: {\n        source: \"comparison_summary\",\n        match: oldDoc.json.textBody === newDoc.json.textBody,\n        v1Length: oldDoc.json.textBody.length,\n        v2Length: newDoc.json.textBody.length\n      }\n    });\n  }\n}\n\nreturn processed;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        0
      ],
      "id": "e64a9a42-aa8b-4fb1-b5c8-d230d1c61508",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "jsCode": "// --- 1. Helper Function: Tokenizer (Splits text into words for comparison) ---\nfunction tokenize(text) {\n  // Split by spaces but keep punctuation attached to words for clearer reading\n  return text.split(/\\s+/).filter(t => t.length > 0);\n}\n\n// --- 2. Helper Function: Compute Diff (Longest Common Subsequence) ---\n// This is a standard computer science algorithm for comparing files\nfunction computeDiff(oldText, newText) {\n  const oldWords = tokenize(oldText);\n  const newWords = tokenize(newText);\n  \n  // Matrix for LCS (Longest Common Subsequence)\n  const matrix = Array(oldWords.length + 1).fill(null).map(() => Array(newWords.length + 1).fill(0));\n\n  for (let i = 1; i <= oldWords.length; i++) {\n    for (let j = 1; j <= newWords.length; j++) {\n      if (oldWords[i - 1] === newWords[j - 1]) {\n        matrix[i][j] = matrix[i - 1][j - 1] + 1;\n      } else {\n        matrix[i][j] = Math.max(matrix[i - 1][j], matrix[i][j - 1]);\n      }\n    }\n  }\n\n  // Backtrack to find changes\n  const changes = [];\n  let i = oldWords.length;\n  let j = newWords.length;\n\n  while (i > 0 || j > 0) {\n    if (i > 0 && j > 0 && oldWords[i - 1] === newWords[j - 1]) {\n      // No change\n      changes.unshift({ type: 'same', value: oldWords[i - 1] });\n      i--; j--;\n    } else if (j > 0 && (i === 0 || matrix[i][j - 1] >= matrix[i - 1][j])) {\n      // Added in new version\n      changes.unshift({ type: 'added', value: newWords[j - 1] });\n      j--;\n    } else {\n      // Removed from old version\n      changes.unshift({ type: 'removed', value: oldWords[i - 1] });\n      i--;\n    }\n  }\n  return changes;\n}\n\n// --- 3. Process the Input Items ---\nconst items = $input.all();\n\n// Use loose matching to find the text bodies\n// Adjust index if your order is flipped (0 vs 1)\nconst doc1 = items.find(i => i.json.source === 'old' || i.json.textBody.includes(\"Version: 1.0\"));\nconst doc2 = items.find(i => i.json.source === 'new' || i.json.textBody.includes(\"Version: 2.0\"));\n\nconst text1 = doc1 ? doc1.json.textBody : (items[0] ? items[0].json.textBody : \"\");\nconst text2 = doc2 ? doc2.json.textBody : (items[1] ? items[1].json.textBody : \"\");\n\n// Calculate the diff\nconst diffResult = computeDiff(text1, text2);\n\n// --- 4. Format Output for Readability ---\n// We group changes into readable sentences\nlet formattedDiff = [];\nlet currentChunk = { type: 'same', text: [] };\n\ndiffResult.forEach(part => {\n  if (part.type === currentChunk.type) {\n    currentChunk.text.push(part.value);\n  } else {\n    // Save previous chunk\n    formattedDiff.push({ \n      status: currentChunk.type.toUpperCase(), \n      content: currentChunk.text.join(' ') \n    });\n    // Start new chunk\n    currentChunk = { type: part.type, text: [part.value] };\n  }\n});\n// Push final chunk\nformattedDiff.push({ status: currentChunk.type.toUpperCase(), content: currentChunk.text.join(' ') });\n\n// Filter out the boring \"SAME\" parts to focus on changes?\n// Or keep it all. Here we filter to show only CONTEXT around changes.\nconst crucialChanges = formattedDiff.filter(c => c.status !== 'SAME' || c.content.length < 50);\n\nreturn {\n  json: {\n    summary: \"Comparison Complete\",\n    totalChanges: diffResult.filter(x => x.type !== 'same').length,\n    // Full detailed list of what changed\n    changes: formattedDiff.filter(x => x.status !== 'SAME'),\n    // Full reconstruction with markers\n    fullDiff: formattedDiff\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1072,
        0
      ],
      "id": "64c72a93-666d-4a8d-8419-63434b833a48",
      "name": "Code in JavaScript2"
    }
  ],
  "connections": {
    "On form submission": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "Compression1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compression1": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Code in JavaScript2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "3191e53f8d7b6f19771697a6634d6f01f60b605c98831986ec819544d636104a"
  }
}